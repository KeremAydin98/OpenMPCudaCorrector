{"prompt":"double sumArrPar_01(int arr[]){\nint nthreads = 16;\ndouble total = 0;\ndouble s_priv[nthreads] = {0};\n\n#pragma omp parallel num_threads(nthreads)\n{\nint t = omp_get_thread_num();\n#pragma omp for\nfor (int i = 0; i < ARRAY_SIZE; i++){\ns_priv[t] += arr[i];\n}\n}\n\nfor (int i = 0; i < nthreads; i++)\n{\ntotal += s_priv[i];\n}\n\nreturn total;\n\n ->","completion":" double sumArrPar_02(int arr[]){\nint nthreads = 16;\ndouble total = 0;\nint PADDING = 8;\ndouble s_priv[nthreads * PADDING] = {0};\n\n#pragma omp parallel num_threads(nthreads)\n{\nint t = omp_get_thread_num();\n#pragma omp for\nfor (int i = 0; i < ARRAY_SIZE; i++){\ns_priv[t * PADDING] += arr[i];\n}\n}\n\nfor (int i = 0; i < nthreads; i++)\n{\ntotal += s_priv[i * PADDING];\n}\n\nreturn total;\n\n"}
{"prompt":"double sumArraysPar_01(int arr1[], int arr2[]){\nint nthreads = 16;\ndouble total = 0;\ndouble s_priv[nthreads] = {0};\n\n#pragma omp parallel num_threads(nthreads)\n{\nint t = omp_get_thread_num();\n#pragma omp for\nfor (int i = 0; i < ARRAY_SIZE; i++){\ns_priv[t] += arr1[i] + arr2[i];\n}\n}\n\nfor (int i = 0; i < nthreads; i++)\n{\ntotal += s_priv[i];\n}\n\nreturn total;\n\n ->","completion":" double sumArraysPar_02(int arr1[], int arr2[]){\nint nthreads = 16;\ndouble total = 0;\nint PADDING = 8;\ndouble s_priv[nthreads * PADDING] = {0};\n\n#pragma omp parallel num_threads(nthreads)\n{\nint t = omp_get_thread_num();\n#pragma omp for\nfor (int i = 0; i < ARRAY_SIZE; i++){\ns_priv[t * PADDING] += arr1[i] + arr2[i];\n}\n}\n\nfor (int i = 0; i < nthreads; i++)\n{\ntotal += s_priv[i * PADDING];\n}\n\nreturn total;\n\n"}
{"prompt":"double multArraysPar_01(int arr1[], int arr2[]){\nint nthreads = 16;\ndouble total = 0;\ndouble s_priv[nthreads] = {0};\n\n#pragma omp parallel num_threads(nthreads)\n{\nint t = omp_get_thread_num();\n#pragma omp for\nfor (int i = 0; i < ARRAY_SIZE; i++){\ns_priv[t] += arr1[i] * arr2[i];\n}\n\n}\n\nfor (int i = 0; i < nthreads; i++)\n{\ntotal += s_priv[i];\n}\n\nreturn total;\n\n ->","completion":" double multArraysPar_02(int arr1[], int arr2[]){\nint nthreads = 16;\ndouble total = 0;\nint PADDING = 8;\ndouble s_priv[nthreads * PADDING] = {0};\n\n#pragma omp parallel num_threads(nthreads)\n{\nint t = omp_get_thread_num();\n#pragma omp for\nfor (int i = 0; i < ARRAY_SIZE; i++){\ns_priv[t * PADDING] += arr1[i] * arr2[i];\n}\n}\n\nfor (int i = 0; i < nthreads; i++)\n{\ntotal += s_priv[i * PADDING];\n}\n\nreturn total;\n\n"}
{"prompt":"double squareSumArraysPar_01(int arr1[], int arr2[]){\nint nthreads = 16;\ndouble total = 0;\ndouble s_priv[nthreads] = {0};\n\n#pragma omp parallel num_threads(nthreads)\n{\nint t = omp_get_thread_num();\n#pragma omp for\nfor (int i = 0; i < ARRAY_SIZE; i++){\ns_priv[t] += arr1[i] * arr1[i] + arr2[i] * arr2[i];\n}\n}\n\nfor (int i = 0; i < nthreads; i++)\n{\ntotal += s_priv[i];\n}\n\nreturn total;\n\n ->","completion":" double squareSumArraysPar_02(int arr1[], int arr2[]){\nint nthreads = 16;\ndouble total = 0;\nint PADDING = 8;\ndouble s_priv[nthreads * PADDING] = {0};\n\n#pragma omp parallel num_threads(nthreads)\n{\nint t = omp_get_thread_num();\n#pragma omp for\nfor (int i = 0; i < ARRAY_SIZE; i++){\ns_priv[t * PADDING] += arr1[i] * arr1[i] + arr2[i] * arr2[i];\n}\n}\n\nfor (int i = 0; i < nthreads; i++)\n{\ntotal += s_priv[i * PADDING];\n}\n\nreturn total;\n\n"}
{"prompt":"double multSumArrScalarPar_01(int arr[], int scalar){\nint nthreads = 16;\ndouble total = 0;\ndouble s_priv[nthreads] = {0};\n\n#pragma omp parallel num_threads(nthreads)\n{\nint t = omp_get_thread_num();\n#pragma omp for\nfor (int i = 0; i < ARRAY_SIZE; i++){\ns_priv[t] += arr[i] * scalar;\n}\n}\n\nfor (int i = 0; i < nthreads; i++)\n{\ntotal += s_priv[i];\n}\n\nreturn total;\n\n ->","completion":" double multSumArrScalarPar_02(int arr[], int scalar){\nint nthreads = 16;\ndouble total = 0;\nint PADDING = 8;\ndouble s_priv[nthreads * PADDING] = {0};\n\n#pragma omp parallel num_threads(nthreads)\n{\nint t = omp_get_thread_num();\n#pragma omp for\nfor (int i = 0; i < ARRAY_SIZE; i++){\ns_priv[t * PADDING] += arr[i] * scalar;\n}\n}\n\nfor (int i = 0; i < nthreads; i++)\n{\ntotal += s_priv[i * PADDING];\n}\n\nreturn total;\n\n"}
{"prompt":"double divSumArrScalarPar_01(int arr[], int scalar){\nint nthreads = 16;\ndouble total = 0;\ndouble s_priv[nthreads] = {0};\n\n#pragma omp parallel num_threads(nthreads)\n{\nint t = omp_get_thread_num();\n#pragma omp for\nfor (int i = 0; i < ARRAY_SIZE; i++){\ns_priv[t] += arr[i] \/ scalar;\n}\n}\n\nfor (int i = 0; i < nthreads; i++)\n{\ntotal += s_priv[i];\n}\n\nreturn total;\n\n ->","completion":" double divSumArrScalarPar_02(int arr[], int scalar){\nint nthreads = 16;\ndouble total = 0;\nint PADDING = 8;\ndouble s_priv[nthreads * PADDING] = {0};\n\n#pragma omp parallel num_threads(nthreads)\n{\nint t = omp_get_thread_num();\n#pragma omp for\nfor (int i = 0; i < ARRAY_SIZE; i++){\ns_priv[t * PADDING] += arr[i] \/ scalar;\n}\n}\n\nfor (int i = 0; i < nthreads; i++)\n{\ntotal += s_priv[i * PADDING];\n}\n\nreturn total;\n\n"}
{"prompt":"double calculatePiPar_01(){\n\nstatic long num_steps = 100000;\ndouble step;\ndouble x;\ndouble pi;\nstep = 1.0\/(double) num_steps;\n\nint nthreads = 16;\ndouble s_priv[nthreads] = {0};\n\n#pragma omp parallel num_threads(nthreads)\n{\nint t = omp_get_thread_num();\n\n#pragma omp for\nfor (int i = 0; i < num_steps; i++){\nx = (i + 0.5) * step;\ns_priv[t] += 4.0 \/ (1.0 + x*x);\n}\n}\n\nfor (int i = 0; i < nthreads; i++)\n{\npi += step * s_priv[i];\n}\n\nreturn pi;\n\n ->","completion":" double calculatePiPar_02(){\n\nstatic long num_steps = 100000;\ndouble step;\ndouble x;\ndouble pi;\nstep = 1.0\/(double) num_steps;\n\nint nthreads = 16;\nint PAD = 8;\ndouble s_priv[nthreads * PAD] = {0};\n\n#pragma omp parallel num_threads(nthreads)\n{\nint t = omp_get_thread_num();\n\n#pragma omp for\nfor (int i = 0; i < num_steps; i++){\nx = (i + 0.5) * step;\ns_priv[t * PAD] += 4.0 \/ (1.0 + x*x);\n}\n}\n\nfor (int i = 0; i < nthreads; i++)\n{\npi += step * s_priv[i * PAD];\n}\n\nreturn pi;\n\n"}
{"prompt":"int maxArrPar_01(int arr[]){\nint nthreads = 16;\nint result = 0;\nint s_priv[nthreads] = {0};\n\n#pragma omp parallel num_threads(nthreads)\n{\nint t = omp_get_thread_num();\nint maxVal = -1;\n#pragma omp for\nfor (int i = 0; i < ARRAY_SIZE; i++){\nif (arr[i] > maxVal){\nmaxVal = arr[i];\ns_priv[t] = arr[i];\n}\n}\n}\n\nint temp = -1;\nfor (int i = 0; i < nthreads; i++)\n{\nif (s_priv[i] > temp){\ntemp = s_priv[i];\nresult = temp;\n}\n}\n\nreturn result;\n\n ->","completion":" int maxArrPar_02(int arr[]){\n\nint nthreads = 16;\nint result = 0;\nint PAD = 8;\nint s_priv[nthreads * PAD] = {0};\n\n#pragma omp parallel num_threads(nthreads)\n{\nint t = omp_get_thread_num();\nint maxVal = -1;\n#pragma omp for\nfor (int i = 0; i < ARRAY_SIZE; i++){\nif (arr[i] > maxVal){\nmaxVal = arr[i];\ns_priv[t * PAD] = arr[i];\n}\n}\n}\n\nint temp = -1;\nfor (int i = 0; i < nthreads; i++)\n{\nif (s_priv[i * PAD] > temp){\ntemp = s_priv[i * PAD];\nresult = temp;\n}\n}\n\nreturn result;\n\n"}
{"prompt":"int minArrPar_01(int arr[]){\nint nthreads = 16;\nint result = 0;\nint s_priv[nthreads] = {0};\n\n#pragma omp parallel num_threads(nthreads)\n{\nint t = omp_get_thread_num();\nint minVal = 9999;\n#pragma omp for\nfor (int i = 0; i < ARRAY_SIZE; i++){\nif (arr[i] < minVal){\nminVal = arr[i];\ns_priv[t] = arr[i];\n}\n}\n}\n\nint temp = 9999;\nfor (int i = 0; i < nthreads; i++)\n{\nif (s_priv[i] < temp){\ntemp = s_priv[i];\nresult = temp;\n}\n}\n\nreturn result;\n\n ->","completion":" int minArrPar_02(int arr[]){\n\nint nthreads = 16;\nint result = 0;\nint PAD = 8;\nint s_priv[nthreads * PAD] = {0};\n\n#pragma omp parallel num_threads(nthreads)\n{\nint t = omp_get_thread_num();\nint minVal = 9999;\n#pragma omp for\nfor (int i = 0; i < ARRAY_SIZE; i++){\nif (arr[i] < minVal){\nminVal = arr[i];\ns_priv[t * PAD] = arr[i];\n}\n}\n}\n\nint temp = 9999;\nfor (int i = 0; i < nthreads; i++)\n{\nif (s_priv[i * PAD] < temp){\ntemp = s_priv[i * PAD];\nresult = temp;\n}\n}\n\nreturn result;\n\n"}
{"prompt":"int countArrScalarPar_01(int arr[], int scalar){\nint nthreads = 16;\ndouble total = 0;\ndouble s_priv[nthreads] = {0};\n\n#pragma omp parallel num_threads(nthreads)\n{\nint t = omp_get_thread_num();\n#pragma omp for\nfor (int i = 0; i < ARRAY_SIZE; i++){\nif (arr[i] == scalar){\ns_priv[t]++;\n}\n}\n}\n\nfor (int i = 0; i < nthreads; i++)\n{\ntotal += s_priv[i];\n}\n\nreturn total;\n\n ->","completion":" double countArrScalarPar_02(int arr[], int scalar){\nint nthreads = 16;\ndouble total = 0;\nint PADDING = 8;\ndouble s_priv[nthreads * PADDING] = {0};\n\n#pragma omp parallel num_threads(nthreads)\n{\nint t = omp_get_thread_num();\n#pragma omp for\nfor (int i = 0; i < ARRAY_SIZE; i++){\nif (arr[i] == scalar){\ns_priv[t * PADDING]++;\n}\n}\n}\n\nfor (int i = 0; i < nthreads; i++)\n{\ntotal += s_priv[i * PADDING];\n}\n\nreturn total;\n\n"}
