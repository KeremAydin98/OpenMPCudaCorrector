double calculatePiPar_02(){	
	
	static long num_steps = 100000;	
	double step; 
	double x;
    double pi;
	step = 1.0/(double) num_steps;

	int nthreads = 16;
	int PAD = 8;
	double s_priv[nthreads * PAD] = {0};
	
	#pragma omp parallel num_threads(nthreads)
	{
		int t = omp_get_thread_num();

		#pragma omp for
		for (int i = 0; i < num_steps; i++){
			x = (i + 0.5) * step;
			s_priv[t * PAD] += 4.0 / (1.0 + x*x);
		}
	}
	
	for (int i = 0; i < nthreads; i++)
	{
		pi += step * s_priv[i * PAD];
	}
	
	return pi;
}